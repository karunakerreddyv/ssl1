# =============================================================================
# Logstash Filter - Celery Workers (Training, Prediction, Monitoring, Beat)
# Pravaha Platform Enterprise Logging
# =============================================================================

filter {
  if [pravaha_service] =~ /^celery-/ {
    # Determine worker type from service name
    if [pravaha_service] == "celery-training" {
      mutate {
        add_field => { "worker_type" => "training" }
      }
    } else if [pravaha_service] == "celery-prediction" {
      mutate {
        add_field => { "worker_type" => "prediction" }
      }
    } else if [pravaha_service] == "celery-monitoring" {
      mutate {
        add_field => { "worker_type" => "monitoring" }
      }
    } else if [pravaha_service] == "celery-beat" {
      mutate {
        add_field => { "worker_type" => "scheduler" }
      }
    }

    # Attempt to parse as JSON first
    json {
      source => "message"
      target => "celery"
      skip_on_invalid_json => true
      tag_on_failure => ["_celery_json_failure"]
    }

    if [celery] {
      # Extract fields from JSON log
      if [celery][levelname] or [celery][level] {
        if [celery][levelname] {
          mutate {
            add_field => { "log_level" => "%{[celery][levelname]}" }
          }
        } else {
          mutate {
            add_field => { "log_level" => "%{[celery][level]}" }
          }
        }
        mutate {
          lowercase => ["log_level"]
        }
      }

      if [celery][message] or [celery][msg] {
        if [celery][message] {
          mutate {
            add_field => { "log_message" => "%{[celery][message]}" }
          }
        } else {
          mutate {
            add_field => { "log_message" => "%{[celery][msg]}" }
          }
        }
      }

      if [celery][task_id] {
        mutate {
          add_field => { "task_id" => "%{[celery][task_id]}" }
        }
      }

      if [celery][task_name] or [celery][task] {
        if [celery][task_name] {
          mutate {
            add_field => { "task_name" => "%{[celery][task_name]}" }
          }
        } else {
          mutate {
            add_field => { "task_name" => "%{[celery][task]}" }
          }
        }
      }

      if [celery][status] or [celery][state] {
        if [celery][status] {
          mutate {
            add_field => { "task_status" => "%{[celery][status]}" }
          }
        } else {
          mutate {
            add_field => { "task_status" => "%{[celery][state]}" }
          }
        }
      }

      if [celery][runtime] or [celery][duration] {
        if [celery][runtime] {
          mutate {
            add_field => { "task_runtime_seconds" => "%{[celery][runtime]}" }
          }
        } else {
          mutate {
            add_field => { "task_runtime_seconds" => "%{[celery][duration]}" }
          }
        }
        mutate {
          convert => { "task_runtime_seconds" => "float" }
        }
      }

      if [celery][retries] {
        mutate {
          add_field => { "task_retries" => "%{[celery][retries]}" }
        }
        mutate {
          convert => { "task_retries" => "integer" }
        }
      }

      if [celery][model_id] {
        mutate {
          add_field => { "model_id" => "%{[celery][model_id]}" }
        }
      }

      if [celery][tenant_id] {
        mutate {
          add_field => { "tenant_id" => "%{[celery][tenant_id]}" }
        }
      }

    } else {
      # Parse Celery standard log format
      # Format: [timestamp: LEVEL/PROCESS] message
      # Or: [timestamp: LEVEL] Task task_name[task_id] message
      grok {
        match => {
          "message" => [
            "\[%{TIMESTAMP_ISO8601:log_timestamp}:\s*%{LOGLEVEL:log_level}/%{DATA:process_name}\]\s*%{GREEDYDATA:log_message}",
            "\[%{TIMESTAMP_ISO8601:log_timestamp}:\s*%{LOGLEVEL:log_level}\]\s*Task\s+%{DATA:task_name}\[%{UUID:task_id}\]\s*%{GREEDYDATA:log_message}",
            "\[%{TIMESTAMP_ISO8601:log_timestamp}:\s*%{LOGLEVEL:log_level}\]\s*%{GREEDYDATA:log_message}",
            "%{LOGLEVEL:log_level}/%{DATA:process_name}\s*%{GREEDYDATA:log_message}",
            "Task\s+%{DATA:task_name}\[%{UUID:task_id}\]\s*%{WORD:task_status}:?\s*%{GREEDYDATA:log_message}",
            "%{GREEDYDATA:log_message}"
          ]
        }
        tag_on_failure => ["_celery_grok_failure"]
      }

      if [log_level] {
        mutate {
          lowercase => ["log_level"]
        }
      } else {
        mutate {
          add_field => { "log_level" => "info" }
        }
      }

      # Parse timestamp
      if [log_timestamp] {
        date {
          match => ["log_timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS"]
          target => "@timestamp"
          remove_field => ["log_timestamp"]
        }
      }
    }

    # Normalize log levels
    if [log_level] == "warning" {
      mutate {
        replace => { "log_level" => "warn" }
      }
    } else if [log_level] == "critical" {
      mutate {
        replace => { "log_level" => "error" }
      }
    }

    # Extract task information from message if not already present
    if ![task_id] and [message] =~ /\[.*-.*-.*-.*-.*\]/ {
      grok {
        match => { "message" => "\[(?<task_id>[a-f0-9-]{36})\]" }
        tag_on_failure => []
      }
    }

    if ![task_name] and [message] =~ /Task\s+/ {
      grok {
        match => { "message" => "Task\s+(?<task_name>[a-zA-Z0-9_.]+)" }
        tag_on_failure => []
      }
    }

    # Detect task states from message
    if ![task_status] {
      if [message] =~ /succeeded/i {
        mutate { add_field => { "task_status" => "SUCCESS" } }
      } else if [message] =~ /failed/i or [message] =~ /failure/i {
        mutate { add_field => { "task_status" => "FAILURE" } }
      } else if [message] =~ /retry/i or [message] =~ /retrying/i {
        mutate { add_field => { "task_status" => "RETRY" } }
      } else if [message] =~ /received/i or [message] =~ /queued/i {
        mutate { add_field => { "task_status" => "PENDING" } }
      } else if [message] =~ /started/i or [message] =~ /running/i {
        mutate { add_field => { "task_status" => "STARTED" } }
      }
    }

    # Extract runtime from "succeeded in Xs" pattern
    if ![task_runtime_seconds] and [message] =~ /succeeded in \d+/ {
      grok {
        match => { "message" => "succeeded in (?<task_runtime_seconds>[0-9.]+)s" }
        tag_on_failure => []
      }
      if [task_runtime_seconds] {
        mutate {
          convert => { "task_runtime_seconds" => "float" }
        }
      }
    }

    # Mark failures with error log level
    if [task_status] == "FAILURE" {
      mutate {
        replace => { "log_level" => "error" }
      }
    }
  }
}
