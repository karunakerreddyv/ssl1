# =============================================================================
# Logstash Filter - ML Service (FastAPI/Uvicorn)
# Pravaha Platform Enterprise Logging
# =============================================================================

filter {
  if [pravaha_service] == "ml-service" {
    # Attempt to parse as JSON first (ML service outputs JSON logs)
    json {
      source => "message"
      target => "mlservice"
      skip_on_invalid_json => true
      tag_on_failure => ["_mlservice_json_failure"]
    }

    if [mlservice] {
      # Extract fields from JSON log
      if [mlservice][level] or [mlservice][levelname] {
        if [mlservice][level] {
          mutate {
            add_field => { "log_level" => "%{[mlservice][level]}" }
          }
        } else {
          mutate {
            add_field => { "log_level" => "%{[mlservice][levelname]}" }
          }
        }
        mutate {
          lowercase => ["log_level"]
        }
      }

      if [mlservice][message] or [mlservice][msg] {
        if [mlservice][message] {
          mutate {
            add_field => { "log_message" => "%{[mlservice][message]}" }
          }
        } else {
          mutate {
            add_field => { "log_message" => "%{[mlservice][msg]}" }
          }
        }
      }

      if [mlservice][model_id] {
        mutate {
          add_field => { "model_id" => "%{[mlservice][model_id]}" }
        }
      }

      if [mlservice][prediction_id] {
        mutate {
          add_field => { "prediction_id" => "%{[mlservice][prediction_id]}" }
        }
      }

      if [mlservice][task_id] {
        mutate {
          add_field => { "task_id" => "%{[mlservice][task_id]}" }
        }
      }

      if [mlservice][inference_time] or [mlservice][duration] {
        if [mlservice][inference_time] {
          mutate {
            add_field => { "inference_time_ms" => "%{[mlservice][inference_time]}" }
          }
        } else {
          mutate {
            add_field => { "inference_time_ms" => "%{[mlservice][duration]}" }
          }
        }
        mutate {
          convert => { "inference_time_ms" => "float" }
        }
      }

      if [mlservice][request_id] {
        mutate {
          add_field => { "request_id" => "%{[mlservice][request_id]}" }
        }
      }

      if [mlservice][tenant_id] {
        mutate {
          add_field => { "tenant_id" => "%{[mlservice][tenant_id]}" }
        }
      }

      if [mlservice][user_id] {
        mutate {
          add_field => { "user_id" => "%{[mlservice][user_id]}" }
        }
      }

      if [mlservice][algorithm] {
        mutate {
          add_field => { "algorithm" => "%{[mlservice][algorithm]}" }
        }
      }

      if [mlservice][endpoint] or [mlservice][path] {
        if [mlservice][endpoint] {
          mutate {
            add_field => { "request_path" => "%{[mlservice][endpoint]}" }
          }
        } else {
          mutate {
            add_field => { "request_path" => "%{[mlservice][path]}" }
          }
        }
      }

      if [mlservice][method] {
        mutate {
          add_field => { "http_method" => "%{[mlservice][method]}" }
        }
      }

      if [mlservice][status_code] {
        mutate {
          add_field => { "http_status" => "%{[mlservice][status_code]}" }
        }
        mutate {
          convert => { "http_status" => "integer" }
        }
      }

    } else {
      # Parse Uvicorn access log format
      # Format: IP:PORT - "METHOD PATH HTTP/VERSION" STATUS
      if [message] =~ /^\d+\.\d+\.\d+\.\d+:\d+\s+-\s+"/ {
        grok {
          match => {
            "message" => "%{IPORHOST:client_ip}:%{POSINT:client_port}\s+-\s+\"%{WORD:http_method}\s+%{NOTSPACE:request_path}\s+HTTP/%{NUMBER:http_version}\"\s+%{NUMBER:http_status:int}"
          }
          tag_on_failure => ["_uvicorn_access_failure"]
        }

        mutate {
          add_field => { "log_level" => "info" }
          add_field => { "uvicorn_log_type" => "access" }
        }

        # Categorize by status code
        if [http_status] >= 500 {
          mutate { replace => { "log_level" => "error" } }
        } else if [http_status] >= 400 {
          mutate { replace => { "log_level" => "warn" } }
        }

      } else {
        # Parse Python log format
        grok {
          match => {
            "message" => [
              "%{LOGLEVEL:log_level}:\s+%{DATA:logger_name}:\s*%{GREEDYDATA:log_message}",
              "%{TIMESTAMP_ISO8601:log_timestamp}\s+-\s+%{DATA:logger_name}\s+-\s+%{LOGLEVEL:log_level}\s+-\s+%{GREEDYDATA:log_message}",
              "\[%{LOGLEVEL:log_level}\]\s*%{GREEDYDATA:log_message}",
              "%{GREEDYDATA:log_message}"
            ]
          }
          tag_on_failure => ["_mlservice_grok_failure"]
        }

        if [log_level] {
          mutate {
            lowercase => ["log_level"]
          }
        } else {
          mutate {
            add_field => { "log_level" => "info" }
          }
        }

        if [log_timestamp] {
          date {
            match => ["log_timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS"]
            target => "@timestamp"
            remove_field => ["log_timestamp"]
          }
        }
      }
    }

    # Normalize log levels
    if [log_level] == "warning" {
      mutate {
        replace => { "log_level" => "warn" }
      }
    } else if [log_level] == "critical" {
      mutate {
        replace => { "log_level" => "error" }
      }
    }

    # Extract model/prediction IDs from messages
    if ![model_id] and [message] =~ /model[_-]?id/ {
      grok {
        match => { "message" => "model[_-]?id[\":\s]+(?<model_id>[a-f0-9-]{36}|[a-zA-Z0-9_-]+)" }
        tag_on_failure => []
      }
    }

    if ![prediction_id] and [message] =~ /prediction[_-]?id/ {
      grok {
        match => { "message" => "prediction[_-]?id[\":\s]+(?<prediction_id>[a-f0-9-]{36}|[a-zA-Z0-9_-]+)" }
        tag_on_failure => []
      }
    }
  }
}
