# =============================================================================
# Logstash Filter - NGINX Access and Error Logs
# Pravaha Platform Enterprise Logging
# =============================================================================

filter {
  if [pravaha_service] == "nginx" {
    # Determine log type (access vs error)
    if [log][file][path] =~ /access\.log/ or [message] =~ /^\d+\.\d+\.\d+\.\d+\s+-\s+/ {
      mutate {
        add_field => { "nginx_log_type" => "access" }
      }

      # Parse NGINX access log (custom format with timing)
      # Format: $remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for" rt=$request_time uct="$upstream_connect_time" uht="$upstream_header_time" urt="$upstream_response_time"
      grok {
        match => {
          "message" => [
            "%{IPORHOST:client_ip} - %{DATA:remote_user} \[%{HTTPDATE:nginx_timestamp}\] \"%{WORD:http_method} %{NOTSPACE:request_uri} HTTP/%{NUMBER:http_version}\" %{NUMBER:http_status:int} %{NUMBER:body_bytes:int} \"%{DATA:http_referer}\" \"%{DATA:user_agent}\" \"%{DATA:x_forwarded_for}\" rt=%{NUMBER:request_time:float} uct=\"%{DATA:upstream_connect_time}\" uht=\"%{DATA:upstream_header_time}\" urt=\"%{DATA:upstream_response_time}\"",
            "%{IPORHOST:client_ip} - %{DATA:remote_user} \[%{HTTPDATE:nginx_timestamp}\] \"%{WORD:http_method} %{NOTSPACE:request_uri} HTTP/%{NUMBER:http_version}\" %{NUMBER:http_status:int} %{NUMBER:body_bytes:int} \"%{DATA:http_referer}\" \"%{DATA:user_agent}\"",
            "%{IPORHOST:client_ip} - %{DATA:remote_user} \[%{HTTPDATE:nginx_timestamp}\] \"%{DATA:request}\" %{NUMBER:http_status:int} %{NUMBER:body_bytes:int}"
          ]
        }
        tag_on_failure => ["_nginx_access_parse_failure"]
      }

      # Parse timestamp
      if [nginx_timestamp] {
        date {
          match => ["nginx_timestamp", "dd/MMM/yyyy:HH:mm:ss Z"]
          target => "@timestamp"
          remove_field => ["nginx_timestamp"]
        }
      }

      # Convert upstream times to floats (they might be "-" for errors)
      if [upstream_connect_time] and [upstream_connect_time] != "-" {
        mutate {
          convert => { "upstream_connect_time" => "float" }
        }
      } else {
        mutate {
          remove_field => ["upstream_connect_time"]
        }
      }

      if [upstream_header_time] and [upstream_header_time] != "-" {
        mutate {
          convert => { "upstream_header_time" => "float" }
        }
      } else {
        mutate {
          remove_field => ["upstream_header_time"]
        }
      }

      if [upstream_response_time] and [upstream_response_time] != "-" {
        mutate {
          convert => { "upstream_response_time" => "float" }
        }
      } else {
        mutate {
          remove_field => ["upstream_response_time"]
        }
      }

      # Extract request path (without query string)
      if [request_uri] {
        grok {
          match => { "request_uri" => "^%{URIPATH:request_path}(?:\?%{GREEDYDATA:query_string})?" }
          tag_on_failure => []
        }
      }

      # Determine target service from path
      if [request_path] {
        if [request_path] =~ /^\/api/ {
          mutate { add_field => { "target_service" => "backend" } }
        } else if [request_path] =~ /^\/ml/ {
          mutate { add_field => { "target_service" => "ml-service" } }
        } else if [request_path] =~ /^\/insights/ {
          mutate { add_field => { "target_service" => "superset" } }
        } else if [request_path] =~ /^\/logs/ {
          mutate { add_field => { "target_service" => "grafana" } }
        } else if [request_path] =~ /^\/elk/ {
          mutate { add_field => { "target_service" => "kibana" } }
        } else {
          mutate { add_field => { "target_service" => "frontend" } }
        }
      }

      # Categorize HTTP status
      if [http_status] {
        if [http_status] >= 500 {
          mutate { add_field => { "log_level" => "error" } }
        } else if [http_status] >= 400 {
          mutate { add_field => { "log_level" => "warn" } }
        } else {
          mutate { add_field => { "log_level" => "info" } }
        }
      }

    } else {
      # NGINX error log
      mutate {
        add_field => { "nginx_log_type" => "error" }
      }

      # Parse NGINX error log
      grok {
        match => {
          "message" => [
            "%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME} \[%{LOGLEVEL:nginx_level}\] %{POSINT:pid}#%{NUMBER:tid}: (?:\*%{NUMBER:connection_id} )?%{GREEDYDATA:error_message}",
            "\[%{LOGLEVEL:nginx_level}\] %{GREEDYDATA:error_message}"
          ]
        }
        tag_on_failure => ["_nginx_error_parse_failure"]
      }

      # Normalize log level
      if [nginx_level] {
        mutate {
          lowercase => ["nginx_level"]
          rename => { "nginx_level" => "log_level" }
        }
      } else {
        mutate {
          add_field => { "log_level" => "error" }
        }
      }
    }

    # Clean up user agent string
    if [user_agent] and [user_agent] == "-" {
      mutate {
        remove_field => ["user_agent"]
      }
    }

    # Clean up referer
    if [http_referer] and [http_referer] == "-" {
      mutate {
        remove_field => ["http_referer"]
      }
    }
  }
}
