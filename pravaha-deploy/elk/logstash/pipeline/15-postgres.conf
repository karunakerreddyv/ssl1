# =============================================================================
# Logstash Filter - PostgreSQL Database
# Pravaha Platform Enterprise Logging
# =============================================================================

filter {
  if [pravaha_service] == "postgres" {
    # PostgreSQL log format (default format):
    # timestamp [PID] LOG: message
    # timestamp [PID] database@user LOG: message
    grok {
      match => {
        "message" => [
          "%{TIMESTAMP_ISO8601:log_timestamp}\s+\[%{POSINT:pid}\]\s+(?:%{DATA:database}@%{DATA:db_user}\s+)?%{LOGLEVEL:log_level}:\s*%{GREEDYDATA:log_message}",
          "%{TIMESTAMP_ISO8601:log_timestamp}\s+%{WORD:timezone}\s+\[%{POSINT:pid}\]\s+(?:%{DATA:database}@%{DATA:db_user}\s+)?%{LOGLEVEL:log_level}:\s*%{GREEDYDATA:log_message}",
          "\[%{POSINT:pid}\]\s+%{LOGLEVEL:log_level}:\s*%{GREEDYDATA:log_message}",
          "%{LOGLEVEL:log_level}:\s*%{GREEDYDATA:log_message}",
          "%{GREEDYDATA:log_message}"
        ]
      }
      tag_on_failure => ["_postgres_grok_failure"]
    }

    # Parse timestamp
    if [log_timestamp] {
      date {
        match => ["log_timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd HH:mm:ss"]
        target => "@timestamp"
        remove_field => ["log_timestamp"]
      }
    }

    # Normalize log levels
    if [log_level] {
      mutate {
        lowercase => ["log_level"]
      }

      # PostgreSQL specific levels
      if [log_level] == "log" {
        mutate {
          replace => { "log_level" => "info" }
        }
      } else if [log_level] == "warning" {
        mutate {
          replace => { "log_level" => "warn" }
        }
      } else if [log_level] == "fatal" or [log_level] == "panic" {
        mutate {
          replace => { "log_level" => "error" }
        }
      } else if [log_level] == "notice" {
        mutate {
          replace => { "log_level" => "info" }
        }
      } else if [log_level] == "statement" {
        mutate {
          replace => { "log_level" => "debug" }
        }
      }
    } else {
      mutate {
        add_field => { "log_level" => "info" }
      }
    }

    # Extract duration from slow query logs
    if [log_message] =~ /duration:/ {
      grok {
        match => { "log_message" => "duration:\s*(?<query_duration_ms>[0-9.]+)\s*ms" }
        tag_on_failure => []
      }
      if [query_duration_ms] {
        mutate {
          convert => { "query_duration_ms" => "float" }
          add_field => { "is_slow_query" => "true" }
        }
      }
    }

    # Extract statement/query if present
    if [log_message] =~ /statement:/ {
      grok {
        match => { "log_message" => "statement:\s*%{GREEDYDATA:sql_statement}" }
        tag_on_failure => []
      }
      mutate {
        add_field => { "contains_sql" => "true" }
      }
    }

    # Detect connection events
    if [log_message] =~ /connection authorized/ or [log_message] =~ /connection received/ {
      mutate {
        add_field => { "event_type" => "connection_start" }
      }
    } else if [log_message] =~ /disconnection/ {
      mutate {
        add_field => { "event_type" => "connection_end" }
      }
    }

    # Extract client IP from connection logs
    if [log_message] =~ /connection received.*host=/ {
      grok {
        match => { "log_message" => "host=(?<client_ip>[^\s,]+)" }
        tag_on_failure => []
      }
    }

    # Detect checkpoint events
    if [log_message] =~ /checkpoint/ {
      mutate {
        add_field => { "event_type" => "checkpoint" }
      }
    }

    # Detect deadlock
    if [log_message] =~ /deadlock detected/ {
      mutate {
        replace => { "log_level" => "error" }
        add_field => { "event_type" => "deadlock" }
      }
    }

    # Detect lock wait timeout
    if [log_message] =~ /lock timeout/ or [log_message] =~ /statement timeout/ {
      mutate {
        replace => { "log_level" => "warn" }
        add_field => { "event_type" => "timeout" }
      }
    }

    # Convert PID to integer
    if [pid] {
      mutate {
        convert => { "pid" => "integer" }
      }
    }
  }
}
